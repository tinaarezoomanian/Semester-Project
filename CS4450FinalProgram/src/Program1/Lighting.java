/***************************************************************
* file: Lighting.java
* author: Kenneth Chau, Tina Arezoomanians, Kelly Lwin
* class: CS 4450.01 (S25-Regular) Computer Graphics
*
* assignment: Final Program Checkpoint 3
* date last modified: 4/25/2025
*
* purpose: The program displays a world with correctly placed blocks for the generated terrain, and a light source  that will leave half the world brightly lit and the other
half dimly illuminated following Phong's model with directional lighting
* note: The program contains code that is assisted but not generated by AI.
****************************************************************/

package Program1;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.FloatBuffer;
import org.lwjgl.opengl.GL11;

public class Lighting {
    // method - initLighting  
    // purpose - sets up light source and material for the scene  
    public static void initLighting() {
        GL11.glEnable(GL11.GL_LIGHTING);
        GL11.glEnable(GL11.GL_LIGHT0);

        // color material to use texture colors
        GL11.glEnable(GL11.GL_COLOR_MATERIAL);
        GL11.glColorMaterial(GL11.GL_FRONT_AND_BACK, GL11.GL_AMBIENT_AND_DIFFUSE);
        
        // directional light from the positive X direction
        float[] lightPosition = {1.0f, 0.0f, 0.0f, 0.0f}; // directional
        float[] ambientLight = {0.2f, 0.2f, 0.2f, 1.0f};  // dimambient light
        float[] diffuseLight = {0.8f, 0.8f, 0.8f, 1.0f};  // bright diffuse light
        float[] specularLight = {0.5f, 0.5f, 0.5f, 1.0f}; // specular for shine

        GL11.glLight(GL11.GL_LIGHT0, GL11.GL_POSITION, createFloatBuffer(lightPosition));
        GL11.glLight(GL11.GL_LIGHT0, GL11.GL_AMBIENT, createFloatBuffer(ambientLight));
        GL11.glLight(GL11.GL_LIGHT0, GL11.GL_DIFFUSE, createFloatBuffer(diffuseLight));
        GL11.glLight(GL11.GL_LIGHT0, GL11.GL_SPECULAR, createFloatBuffer(specularLight));

        // material properties for cubes
        float[] materialSpecular = {0.5f, 0.5f, 0.5f, 1.0f};
        float[] materialShininess = {10.0f, 0.0f, 0.0f, 0.0f};
        GL11.glMaterial(GL11.GL_FRONT_AND_BACK, GL11.GL_SPECULAR, createFloatBuffer(materialSpecular));
        GL11.glMaterial(GL11.GL_FRONT_AND_BACK, GL11.GL_SHININESS, createFloatBuffer(materialShininess));

        // normalization to handle scaling
        GL11.glEnable(GL11.GL_NORMALIZE);
    }

    // method - createFloatBuffer  
    // purpose - converts a float array to a FloatBuffer for opengl 
    private static FloatBuffer createFloatBuffer(float[] values) {
        FloatBuffer buffer = ByteBuffer
            .allocateDirect(values.length * 4)
            .order(ByteOrder.nativeOrder())
            .asFloatBuffer();
        buffer.put(values).flip();
        return buffer;
    }

    // method - updateLight  
    // purpose - reapplies light position each frame  
    public static void updateLight() {
        // reapply light position after camera transformation
        float[] lightPosition = {1.0f, 0.0f, 0.0f, 0.0f};
        GL11.glLight(GL11.GL_LIGHT0, GL11.GL_POSITION, createFloatBuffer(lightPosition));
    }
}
