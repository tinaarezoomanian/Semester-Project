/***************************************************************
* file: Chicken.java
* author: Kenneth Chau, Tina Arezoomanians, Kelly Lwin
* class: CS 4450.01 (S25-Regular) Computer Graphics
*
* assignment: Final Program
* date last modified: 05/04/2025
* 
* purpose: The program create a roaming chicken with MineCraft texture.
* note: The program contains code that is assisted but not generated by AI.
****************************************************************/

package Program1;

import java.util.Random;
import org.lwjgl.opengl.GL11;
import org.newdawn.slick.openal.Audio;

public class Chicken {
    public float x, y, z;
    private Audio sound;
    private Random random = new Random();
    private float soundTime = 0;
    private boolean isVocal = false;
    private float direction;
    private static final float SPEED = 0.05f;
    private static final float TURN_CHANCE = 0.02f;
    private static final float SOUND_INTERVAL_MIN = 15.0f;
    private static final float SOUND_INTERVAL_MAX = 25.0f;
    private static final float SOUND_GAIN = 0.1f;

    private static final int frontTex = MyTextureLoader.loadTexture("/textures/chickenfront.png");
    private static final int sideTex = MyTextureLoader.loadTexture("/textures/chickenside.png");
    private static final int bottomTex = MyTextureLoader.loadTexture("/textures/chickenbottom.png");

    public Chicken(float startX, float startZ, Audio sound) {
        this.x = startX;
        this.z = startZ;
        updateHeight();
        this.direction = (float)(Math.random() * 2 * Math.PI);
        this.sound = sound;
    }

    public void update() {
        soundTime += 1.0f / Basic.FRAME_RATE;
        
        // play sound random intervals
        if (sound != null && soundTime >= SOUND_INTERVAL_MIN) {
            if (random.nextFloat() < 0.1f) {
                // play sound from chicken's position
                sound.playAsSoundEffect(1.0f, SOUND_GAIN, false, x, y, z);
                
                // reset timer to random interval
                soundTime = random.nextFloat() * (SOUND_INTERVAL_MAX - SOUND_INTERVAL_MIN);
            }
        }
        
        if (Math.random() < TURN_CHANCE) {
            direction += (Math.random() - 0.5f) * Math.PI / 4;
        }

        float newX = x + SPEED * (float)Math.cos(direction);
        float newZ = z + SPEED * (float)Math.sin(direction);

        if (isValidGround(newX, newZ)) {
            x = newX;
            z = newZ;
            updateHeight();
        } else {
            direction += Math.PI;
        }
    }

    public void draw() {
        GL11.glPushMatrix();
        GL11.glTranslatef(x, y, z);
        GL11.glScalef(0.5f, 0.5f, 0.5f);

        // FRONT
        GL11.glBindTexture(GL11.GL_TEXTURE_2D, frontTex);
        drawQuad(1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1);

        // BACK
        GL11.glBindTexture(GL11.GL_TEXTURE_2D, sideTex);
        drawQuad(-1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1);

        // LEFT
        GL11.glBindTexture(GL11.GL_TEXTURE_2D, sideTex);
        drawQuad(-1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1);

        // RIGHT
        GL11.glBindTexture(GL11.GL_TEXTURE_2D, sideTex);
        drawQuad(1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, -1);

        // TOP
        GL11.glBindTexture(GL11.GL_TEXTURE_2D, sideTex);
        drawQuad(-1, 1, -1, 1, 1, -1, 1, 1, 1, -1, 1, 1);

        // BOTTOM
        GL11.glBindTexture(GL11.GL_TEXTURE_2D, bottomTex);
        drawQuad(-1, -1, 1, 1, -1, 1, 1, -1, -1, -1, -1, -1);

        GL11.glPopMatrix();
    }

    private void drawQuad(float x0, float y0, float z0,
                          float x1, float y1, float z1,
                          float x2, float y2, float z2,
                          float x3, float y3, float z3) {
        GL11.glBegin(GL11.GL_QUADS);
        GL11.glTexCoord2f(0, 0); GL11.glVertex3f(x0, y0, z0);
        GL11.glTexCoord2f(1, 0); GL11.glVertex3f(x1, y1, z1);
        GL11.glTexCoord2f(1, 1); GL11.glVertex3f(x2, y2, z2);
        GL11.glTexCoord2f(0, 1); GL11.glVertex3f(x3, y3, z3);
        GL11.glEnd();
    }

    private void updateHeight() {
        int gridX = Math.round(x / 2f);
        int gridZ = Math.round(z / 2f);
        gridX = Math.max(0, Math.min(gridX, TerrainGenerator.WIDTH - 1));
        gridZ = Math.max(0, Math.min(gridZ, TerrainGenerator.DEPTH - 1));
        float noise = SimplexNoise.noise(gridX * 0.1f, gridZ * 0.1f);
        int height = (int)(((noise + 1) / 2f) * TerrainGenerator.MAX_HEIGHT);
        y = height * 2f + 1f;
    }

    private boolean isValidGround(float newX, float newZ) {
        int gridX = Math.round(newX / 2f);
        int gridZ = Math.round(newZ / 2f);
        return (gridX >= 0 && gridX < TerrainGenerator.WIDTH &&
                gridZ >= 0 && gridZ < TerrainGenerator.DEPTH);
    }
    
    public void setVocal(boolean vocal) {
        this.isVocal = vocal;
    }
}
